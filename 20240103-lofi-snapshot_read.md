# Feature Spec Template

Developer: triump2020

Date: 03/01/2024

Release: 1.2.0

Issue: https://github.com/matrixorigin/matrixone/issues/10397

## 1. Introduction for snapshot read

快照是备份数据的一种有效方式, 用户可以通过命令为account/database/table 创建snapshot.

当用户创建完snapshot之后，事务可以读取用户指定时间点或者快照ID的数据, 即read at snapshot,主要用于数据恢复/回滚场景。
从语义上，类似这样的sql : select * from t snapshot = xxxx(用户指定的时间戳或者快照ID)。

### 1.1 Goals

CN侧事务支持 read at snapshot , 即：事务可以读取用户指定时间戳/快照ID 的数据.

### 1.2 Non Goals

snapshot的创建，查询，删除。

## 2. Design

### 2.1 需要解决的问题

- 涉及到快照读语句的语法
  
    1.用户需要读取某个表的快照/历史数据, 读取表t的快照ID为xxxx 的数据. 

   ```sql
    BEGIN TRANSACTION ISOLATION LEVEL SI;
    SET TRANSACTION SNAPSHOT 'xxxx';
	select * from t;
	COMMIT;
   ```

   <br>
     2.用户需要在某个snapshot 上导出/导入数据:

	```sql
    BEGIN TRANSACTION ISOLATION LEVEL SI;
    SET TRANSACTION SNAPSHOT 'xxxx';
    select * from db.t into outfile 'S3 file name';
    load data infile 'S3 file' into table db.t;
    COMMIT;
	```

    <br> 

- 快照读事务的start ts 及隔离级别/模式 

   1. 对于snapshot read 事务,应该是只读的，不允许update/insert , 事务的start ts 应为用户指定的snapshot id 所对应的timestamp.
   <br>
   2. snapshot read 事务应该运行在SI隔离级别, optimistic 模式.
    <br>
    
    注意：当前MO中事务的隔离级别和模式是全局的.

- 快照读事务获取旧的ckp 

  1. 快照读事务可能需要从TN 中获取较旧的ckp, 而当前CN 状态机(PartitionState与Catalog)中的数据是基于一个最新的ckp + logtail，所以需要
  从TN 中拉取 旧的ckp, 可以通过RPC 方式，与TN 新建一条tcp链接去获取某个表的指定时间戳的ckp(是否新建链接还是复用已有的push 通道待定)?
  <br>

  2. 快照读事务需要一个独立的状态机，将旧的ckp 数据apply 到此状态机中. 当事务提交后，释放状态机.
  <br>

  3. 如果请求的数据版本在当前CN 状态机中已经存在，可以复用已有状态机. 



### 2.2 详细设计
只讨论 single statement 的 snapshot read txn 的设计, 一旦用户 执行 snapshot read , 就单独创建一个事务，事务的类型为 snapshot-read-only.

#### 2.2.1 snapshot-read 事务的partition state
在disttae中 Engine 是全局的，所有事务能看到的快照数据 放在catalog 与 partitions 中. 
 但每个snapshot read 事务 有基于ckp 不用的快照数据, 因此需要为每个snapshot read txn 分配一个独立的snapshot engine. 

```go
type Engine struct {
	sync.RWMutex
	mp         *mpool.MPool
	fs         fileservice.FileService
	ls         lockservice.LockService
	qs         queryservice.QueryService
	hakeeper   logservice.CNHAKeeperClient
	us         udf.Service
	cli        client.TxnClient
	idGen      IDGenerator
	catalog    *cache.CatalogCache // ==元数据的快照==
	tnID       string
	partitions map[[2]uint64]*logtailreplay.Partition // ==table data 的快照==
	packerPool *fileservice.Pool[*types.Packer]

	// XXX related to cn push model
	pClient pushClien
}
```

```go
type Transaction struct {
	sync.Mutex
	engine *Engine
	// readOnly default value is true, once a write happen, then set to false
	readOnly atomic.Bool
	// db       *DB
	// blockId starts at 0 and keeps incrementing,
	// this is used to name the file on s3 and then give it to tae to use
	// not-used now
	// blockId uint64

	// local timestamp for workspace operations
	//meta     *txn.TxnMeta
	op       client.TxnOperator
	sqlCount atomic.Uint64

	// writes cache stores any writes done by txn
	writes []Entry
	// txn workspace size
	workspaceSize uint64

	tnStores []DNStore
	proc     *process.Process

	idGen IDGenerator

	// interim incremental rowid
	rowId [6]uint32
	segId types.Uuid
	// use to cache opened tables on snapshot by current txn.
	tableCache struct {
		cachedIndex int
		tableMap    *sync.Map
	}
	// use to cache databases created by current txn.
	databaseMap *sync.Map
	// use to cache tables created by current txn.
	createMap *sync.Map
	/*
		for deleted table
		CORNER CASE
		create table t1(a int);
		begin;
		drop table t1; // t1 does not exist
		select * from t1; // can not access t1
		create table t2(a int); // new table
		drop table t2;
		create table t2(a int,b int); //new table
		commit;
		show tables; //no table t1; has table t2(a,b)
	*/
	deletedTableMap *sync.Map

	//deletes for uncommitted blocks generated by CN writing S3.
	deletedBlocks *deletedBlocks

	// uncommitted block generated by CN writing S3 -> block's meta location.
	// notice that it's guarded by txn.Lock()
	cnBlkId_Pos map[types.Blockid]Pos
	// committed block belongs to txn's snapshot data -> delta locations for committed block's deletes.
	blockId_tn_delete_metaLoc_batch map[types.Blockid][]*batch.Batch
	//select list for raw batch comes from txn.writes.batch.
	batchSelectList map[*batch.Batch][]int64
	toFreeBatches   map[tableKey][]*batch.Batch

	rollbackCount int
	statementID   int
	statements    []int

	hasS3Op              atomic.Bool
	removed              bool
	startStatementCalled bool
	incrStatementCalled  bool
	syncCommittedTSCount uint64
	pkCount              int
}

```

#### 2.2.2 获取CKP

  snapshot read txn 可能既会访问全局Engine中的快照数据，全局Engine中的数据是基于最新的ckp；
  也会访问 很旧的ckp 数据，所以需要从TN 拉取老的ckp 数据，基于这个ckp apply 到事务自己独立的Engine 中.

  在函数UpdateObjectInfos 中 判断事务是否为snapshot-read 且 snapshot ts < 全局engine中的 的checkpoint 的时间戳.
  则从TN 拉取ckp 并回放到 snapshot engine 中.

 ```go
 func (tbl *txnTable) UpdateObjectInfos(ctx context.Context) (err error) {
	tbl.tnList = []int{0}

	accountId, err := defines.GetAccountId(ctx)
	if err != nil {
		return err
	}
	_, created := tbl.db.txn.createMap.Load(genTableKey(accountId, tbl.tableName, tbl.db.databaseId))
	// check if the table is not created in this txn, and the block infos are not updated, then update:
	// 1. update logtail
	// 2. generate block infos
	// 3. update the blockInfosUpdated and blockInfos fields of the table
	if !created && !tbl.objInfosUpdated {
		if err = tbl.updateLogtail(ctx); err != nil {
			return
		}
		tbl.objInfosUpdated = true
	}
	return
}
 
 ``` 

#### 2.2.3 disttae 与TN 接口

disttae 需要从TN 拉取 旧的ckp 数据及logtail , 建议用pull 方式, 可以复用以下code:


```go
func updatePartitionOfPull(
	primarySeqnum int,
	tbl *txnTable,
	ctx context.Context,
	op client.TxnOperator,
	engine *Engine,
	partition *logtailreplay.Partition,
	tn DNStore,
	req api.SyncLogTailReq,
) error {
	logDebugf(op.Txn(), "updatePartitionOfPull")
	reqs, err := genLogTailReq(tn, req)
	if err != nil {
		return err
	}
	logTails, err := getLogTail(ctx, op, reqs)
	if err != nil {
		return err
	}

	state, doneMutate := partition.MutateState()

	for i := range logTails {
		if err := consumeLogTailOfPull(primarySeqnum, tbl, ctx, engine, state, logTails[i]); err != nil {
			logutil.Errorf("consume %d-%s logtail error: %v\n", tbl.tableId, tbl.tableName, err)
			return err
		}
	}

	doneMutate()

	return nil
}

```

#### 2.2.4  其他修改

 原则上 所有访问 全局 Engine.catalogs 和 Engine.partitions 的 地方 都要修改：判断当前事务是否为snapshot-read 且比较其snapshot ts
 与全局Engine 中的 checkpoint 时间戳 来选择 是从 全局engine 中读取数据还是从 snapshot engine 中读取数据.
 修改的接口:engine/types.go

```go
type Database interface {
	Relations(context.Context) ([]string, error)
	Relation(context.Context, string, any) (Relation, error)

	Delete(context.Context, string) error
	Create(context.Context, string, []TableDef) error // Create Table - (name, table define)
	Truncate(context.Context, string) (uint64, error)
	GetDatabaseId(context.Context) string
	IsSubscription(context.Context) bool
	GetCreateSql(context.Context) string
}
```


```go
type Relation interface {
	Statistics

	UpdateObjectInfos(context.Context) error

	Ranges(context.Context, []*plan.Expr) (Ranges, error)

	TableDefs(context.Context) ([]TableDef, error)

	// Get complete tableDef information, including columns, constraints, partitions, version, comments, etc
	GetTableDef(context.Context) *plan.TableDef

	GetPrimaryKeys(context.Context) ([]*Attribute, error)

	GetHideKeys(context.Context) ([]*Attribute, error)

	Write(context.Context, *batch.Batch) error

	Update(context.Context, *batch.Batch) error

	// Delete(context.Context, *vector.Vector, string) error
	Delete(context.Context, *batch.Batch, string) error

	AddTableDef(context.Context, TableDef) error
	DelTableDef(context.Context, TableDef) error

	// only ConstraintDef can be modified
	UpdateConstraint(context.Context, *ConstraintDef) error

	AlterTable(ctx context.Context, c *ConstraintDef, constraint [][]byte) error

	GetTableID(context.Context) uint64

	// GetTableName returns the name of the table.
	GetTableName() string

	GetDBID(context.Context) uint64

	// second argument is the number of reader, third argument is the filter extend, foruth parameter is the payload required by the engine
	NewReader(context.Context, int, *plan.Expr, []byte) ([]Reader, error)

	TableColumns(ctx context.Context) ([]*Attribute, error)

	//max and min values
	MaxAndMinValues(ctx context.Context) ([][2]any, []uint8, error)

	GetEngineType() EngineType

	GetColumMetadataScanInfo(ctx context.Context, name string) ([]*plan.MetadataScanInfo, error)

	// PrimaryKeysMayBeModified reports whether any rows with any primary keys in keyVector was modified during `from` to `to`
	// If not sure, returns true
	// Initially added for implementing locking rows by primary keys
	PrimaryKeysMayBeModified(ctx context.Context, from types.TS, to types.TS, keyVector *vector.Vector) (bool, error)
}

```



 

